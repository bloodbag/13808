<!DOCTYPE html>
<!--
                              .:'
                 ....     _.::'
               .:-""-:.  (_.'
             .:/      \:.
             :|        |:
             ':\      /:'
              '::-..-::'
                `''''`
-->
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="description" content="Welcome">
		<link rel="icon" href="//13bob.net/world.gif">
		<title>13bob</title>
		<style> html { background-color: black; overflow: hidden; } canvas { width: 100%; height: 100%; position: center; } </style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="Lensflare.js"></script>
		<script>
			var scene, camera, renderer,
			xAxis = new THREE.Vector3(1, 0, 0),
			yAxis = new THREE.Vector3(0, 1, 0),
			zAxis = new THREE.Vector3(0, 0, 1),
			clock = new THREE.Clock(),
			mixers = [], duration = 177, clips = [],
			cameraLook = false,
			objects = [], lights = [],
			line, MAX_POINTS = 50000, drawCount,
			ex = 13, wy = 0, ze = -13;

			function pivotObj(pivot, sequences) {
				var ret = {};
				ret.pivot = pivot;
				ret.sequences = sequences;
				return ret;
			}

			function lightObj(type, light, x, y, z, target, sequences) {
				var ret = {};
				ret.type = type;
				ret.light = light;
				ret.x = x;
				ret.y = y;
				ret.z = z;
				ret.target = target;
				ret.sequences = sequences;
				return ret;
			}

			function sphereObj(mesh, texture, cShadow, rShadow, keyFrames, sequences) {
				var ret = {};
				ret.mesh = mesh;
				ret.texture = texture;
				ret.cShadow = cShadow;
				ret.rShadow = rShadow;
				ret.sequences = sequences;
				return ret;
			}

			function lineObj(line, x1, y1, z1, x2, y2, z2) {
				var ret = {};
				ret.line = line;
				ret.x1 = x1;
				ret.y1 = y1;
				ret.z1 = z1;
				ret.x2 = x2;
				ret.y2 = y2;
				ret.z2 = z2;
				return ret;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function addPivot(x, y, z, d, sequences) {
				pivot = new THREE.Object3D();
				pivot.position.set(x, y, z);
				pivot.add(camera);
				objects.push(new pivotObj(pivot, sequences));
				scene.add(objects[objects.length-1].pivot);
				camera.position.set(0, 0, d);
				camera.rotation.y = (23.5 / Math.PI) / 180;

				var clip = new THREE.AnimationClip("piv", duration, sequences);
				mixers.push(new THREE.AnimationMixer(objects[objects.length-1].pivot));
				clipAction = mixers[mixers.length-1].clipAction(clip);
				clips.push(clipAction);
			}

			function addObj(x, y, z, radius, cthru, tex, cShadow, rShadow, sequences) {
					var texture = new THREE.Texture(tex);
					var material;
					var loader = new Promise(function (resolve) { material = new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(tex, THREE.SphericalRefractionMapping)});}).then(/*audio.play()*/);
					if (cthru) { material.transparent = true; material.opacity = 0.5; }
					//material.wireframe = true;
					var mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 100, 100), material);
					mesh.position.set(x, y, z);
					mesh.rotation.y = 25 / 180;
					mesh.rotation.z = -(23.5  / 180);
					objects.push(new sphereObj(mesh, tex, cShadow, rShadow, sequences));
					mesh.castShadow = objects[objects.length-1].cShadow;
					mesh.receiveShadow = objects[objects.length-1].rShadow;
					scene.add(objects[objects.length-1].mesh);

					var clip = new THREE.AnimationClip(tex.substring(0, objects[objects.length-1].length-4), duration, sequences);
					mixers.push(new THREE.AnimationMixer(objects[objects.length-1].mesh));
					clipAction = mixers[mixers.length-1].clipAction(clip);
					clips.push(clipAction);
			}

			function addSkybox() {
				var materialArray = [];
				materialArray.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('img/skybox/xpos.png')}));
				materialArray.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('img/skybox/xneg.png')}));
				materialArray.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('img/skybox/ypos.png')}));
				materialArray.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('img/skybox/yneg.png')}));
				materialArray.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('img/skybox/zpos.png')}));
				materialArray.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('img/skybox/zneg.png')}));
				for (var i = 0; i < 6; i++) materialArray[i].side = THREE.BackSide;
				var skyboxMaterial = new THREE.MeshFaceMaterial(materialArray);
				var skyboxGeom = new THREE.CubeGeometry(2048, 2048, 2048, 1, 1, 1);
				var skybox = new THREE.Mesh(skyboxGeom, skyboxMaterial);
				scene.add(skybox);
			}

			function addLight(type, x, y, z, target, sequences) {
				switch(type) {
					case 0:
						var light = new THREE.PointLight(0xffffff, 1, 100);
						light.position.set(x, y, z);
						light.castShadow = true;
						light.shadow.mapSize.width = 1024;
						light.shadow.mapSize.height = 1024;
						light.shadow.camera.near = 0.5;
						light.shadow.camera.far = camera.far;
						light.showCameraVisible = true;
						light.shadow.bias = -0.005; // Reduces self-shadowing on double-sided objects
						objects.push(new lightObj(type, light, x, y, z, target, sequences));
						scene.add(objects[objects.length-1].light);

						var clip = new THREE.AnimationClip("light_" + type + "_" + x + y + z, duration, sequences);
						mixers.push(new THREE.AnimationMixer(objects[objects.length-1].light));
						clipAction = mixers[mixers.length-1].clipAction(clip);
						clips.push(clipAction);
					break;
					case 1:
						var light = new THREE.DirectionalLight(0xffffff, 1.0);
						light.position.set(x, y, z);
						light.target = target;
						light.castShadow = true;
						light.shadow.mapSize.width = 1024;
						light.shadow.mapSize.height = 1024;
						light.shadow.camera.near = 0.5;
						light.shadow.camera.far = camera.far;
						light.showCameraVisible = true;
						light.shadow.bias = -0.005; // Reduces self-shadowing on double-sided objects

						var textureLoader = new THREE.TextureLoader(),
						lensflare = new THREE.Lensflare();
						lensflare.addElement(new THREE.LensflareElement(textureLoader.load("img/lens/lens0.png"), 512, 0));
						lensflare.addElement(new THREE.LensflareElement(textureLoader.load("img/lens/lens1.png"), 512, 0));
						lensflare.addElement(new THREE.LensflareElement(textureLoader.load("img/lens/lens2.png"), 60, 0.6));
						light.add(lensflare);

						objects.push(new lightObj(type, light, x, y, z, target, sequences));
						scene.add(objects[objects.length-1].target);
						scene.add(objects[objects.length-1].light);

						var clip = new THREE.AnimationClip("light_" + type + "_" + x + y + z, duration, sequences);
						mixers.push(new THREE.AnimationMixer(objects[objects.length-1].light));
						clipAction = mixers[mixers.length-1].clipAction(clip);
						clips.push(clipAction);
					break;
				}
			}

			/*
			function addLine(x1, y1, z1, x2, y2, z2) {
				var material = new THREE.LineBasicMaterial({color: 0xff0000});
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(x1, y1, z1));
				geometry.vertices.push(new THREE.Vector3(x2, y2, z2));
				var line = new THREE.Line(geometry, material);
				objects.push(new lineObj(line, x1, y1, z1, x2, y2, z2));
				scene.add(line);
			}
			*/

			function updatePositions() {
				var positions = line.geometry.attributes.position.array, index = 0;
				if (mixers.length > 3) { // Light loaded?
					for (var i = 0, l = MAX_POINTS; i < l; i++) {
						positions[index++] = ex;
						positions[index++] = wy;
						positions[index++] = ze;
					    ex = mixers[3].getRoot().position.x;
					    wy = mixers[3].getRoot().position.y;
					    if (mixers.length > 2) ze = mixers[3].getRoot().position.z; // New method: have two lines, one rendered, one deleted, then alternate with new pos
					}
				}
			}

			function init() {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				document.body.appendChild(renderer.domElement);
				window.addEventListener('resize', onWindowResize, false);

				var axesHelper = new THREE.AxesHelper(10);
				//scene.add(axesHelper);

				var ambient = new THREE.AmbientLight(0xffffff);
				ambient.intensity = 0.0333;
				scene.add(ambient);

				var qInitial = new THREE.Quaternion().setFromAxisAngle(yAxis, -Math.PI / 8);
				var qFinal = new THREE.Quaternion().setFromAxisAngle(yAxis, Math.PI / 32);

				// Action
				addSkybox();
				addObj(0, 0, 0, 3, false, "earth.jpg", false, false, []);
				addObj(0, 0, 0, 3.005, true, "clouds.jpg", false, false, []);
				addPivot(1.6, 0.7, 0, 3.3, [new THREE.QuaternionKeyframeTrack('.quaternion', [0, 16], [qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w])]);
				addLight(1, ex, wy, ze, objects[0].mesh, [new THREE.NumberKeyframeTrack('.intensity', [0.7, 1.7], [0, 1.5]), new THREE.VectorKeyframeTrack('.position', [0, 32], [ex, wy, ze, ex, wy, ze + 13])]);

				// first beat: 0.7
				// second: 2.67
				// 16 seconds to get to vocals.

				// Line
				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array(MAX_POINTS * 3); // 3 vertices per point
				geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
				drawCount = 2; // Draw the first 2 points only
				geometry.setDrawRange(0, drawCount);
				var material = new THREE.LineBasicMaterial({color: 0xff0000, linewidth: 2});
				line = new THREE.Line(geometry, material);
				scene.add(line);
				updatePositions();
				// Action

				for (var c = 0; c < clips.length; c++) clips[c].play();
			}

			function render() {
				var delta = clock.getDelta();
				renderer.render(scene, camera);
				for (var m = 0; m < mixers.length; m++) {
					mixers[m].update(delta);
				}
			}

			function anim() {
				requestAnimationFrame(anim);
				drawCount = (drawCount + 1) % MAX_POINTS;
				line.geometry.setDrawRange(0, drawCount);

				if (drawCount === 0) {
					updatePositions();
					line.geometry.attributes.position.needsUpdate = true; // Required after the first render
				} render();
			} init(); anim();
		</script>
	</body>
</html>
